syntax = "proto2";

message DaqifiOutMessage
{
	// Put repetitive information in first 15 fields to keep encoded data as short as possible

	// Begin streaming data
	optional uint32 msg_time_stamp = 1;						//  Incrementing timestamp for each streaming trigger (frequency=timestamp_freq)

	repeated sint32 analog_in_data = 2; 					//  Analog in data int (maximum 24bit/ch) (available to user)
	repeated float analog_in_data_float = 3; 				//  Analog in data float (after cal calcs)(available to user)
	repeated uint32 analog_in_data_ts = 4; 					//  Analog in data timestamp offset (value should be added to msg_time_stamp for absolute timestamp)

	repeated int32 analog_in_data_priv = 5; 				//  Private analog in data int (analog channels for board status - not available to user)
	repeated float analog_in_data_priv_float = 6; 			//  Private analog in data float (after cal calcs) (analog channels for board status - not available to user)
	repeated uint32 analog_in_data_priv_ts = 7; 			//  Private analog in data timestamp offset (value should be added to msg_time_stamp for absolute timestamp)

	optional bytes digital_data = 8;						//  Digital IO data (bitwise binary representation LSB=ch0)
	repeated uint32 digital_data_ts = 9; 					//  Digital IO data timestamp offset (value should be added to msg_time_stamp for absolute timestamp)

	repeated uint32 analog_out_data = 10; 					//  Analog out data int (maximum 12bit/ch)

	optional uint32 device_status = 11;						//	Device status word
	optional uint32 pwr_status = 12;						//  Power status
	optional uint32 batt_status = 13;						//  Battery charge percent
	optional sint32 temp_status = 14;						//  Board temperature in deg C
	// End streaming data

	optional uint32 timestamp_freq = 17;					//  Frequency of the timestamp counter

	// Analog In Information
	optional bytes analog_in_port_num = 18;					//	Number of analog in ports (public)
	optional bytes analog_in_port_num_priv = 19;			//	Number of analog in ports (private)
	optional bytes analog_in_port_rse = 20;					//  Analog in port referenced single ended (RSE)
	optional bytes analog_in_port_enabled = 21;				//  Analog in port enabled list
	repeated float analog_in_port_range = 22;				//	Analog in port voltage range (volts span:RSE 0 to range, NON-RSE -(range/2) to (range/2))
	repeated float analog_in_port_range_priv = 23;			//	Private analog in port voltage range (volts span:RSE 0 to range, NON-RSE -(range/2) to (range/2))
	optional uint32 analog_in_res = 24;						//  Public analog in (ADC) resolution (bits used to convert from integer value to volts)
	optional uint32 analog_in_res_priv = 25;				//  Private analog in (ADC) resolution (bits used to convert from integer value to volts)
	repeated float analog_in_cal_m = 26;					//  Analog in port calibration m value (should be applied to integer value before converting to volts)
	repeated float analog_in_cal_b = 27;					//  Analog in port calibration b value (should be applied to integer value before converting to volts)
	repeated float analog_in_cal_m_priv = 28;				//  Private analog in port calibration m value (should be applied to integer value before converting to volts)
	repeated float analog_in_cal_b_priv = 29;				//  Private analog in port calibration b value (should be applied to integer value before converting to volts)

	// Digital I/O Information
	optional bytes digital_port_num = 30;					//	Number of digital IO ports (public)
	optional bytes digital_port_dir = 31;					//	Digital IO port direction (bitwise binary representation LSB=ch0)

	// Analog Out Information
	optional uint32 analog_out_res = 32;					//  Analog out (DAC) resolution (bits)

	// IPv4 Device Information
	optional bytes ip_addr = 33;							//  Device IP address
	optional bytes net_mask = 34;							//  Network mask
	optional bytes gateway = 35;							//  Default gateway
	optional bytes primary_dns = 36;						//  Primary DNS
	optional bytes secondary_dns = 37;						//  Secondary DNS
	optional bytes mac_addr = 38;							//  Device MAC address

	// IPv6 Device Information
	optional bytes ip_addr_v6 = 39;							//  Device IP address v6
	optional bytes sub_pre_length_v6 = 40;					//  Subnet prefix length v6
	optional bytes gateway_v6 = 41;							//  Default gateway v6
	optional bytes primary_dns_v6 = 42;						//  Primary DNS v6
	optional bytes secondary_dns_v6 = 43;					//  Secondary DNS v6
	optional bytes eui_64 = 44;								//  Device EUI-64 address

	// Device Network Information
	optional string host_name = 45;							//  Device HostName
	optional uint32 device_port = 46;						//	Device port
	optional string friendly_device_name = 47;				//	Device friendly name
	optional string ssid = 48;								//  SSID device is to connect to
	optional uint32 wifi_security_mode = 49;				//  Device WiFi security mode

	// Aviable SSID Information
	repeated string av_ssid = 50;							//  Available SSIDs to connect to
	optional bytes av_ssid_strength = 51;					//  Available SSID strength out of 255
	optional bytes av_ssid_security_mode = 52;				//	Available SSID security mode

	// Device Hardware/Firmware Information
	optional string device_pn = 53;							//  Alphanumeric device P/N
	optional string device_hw_rev = 54;						//  Device hardware revision
	optional string device_fw_rev = 55;						//  Device firmware revision
}

option java_package = "com.tacuna.common.messages";
option java_outer_classname = "ProtoMessageV2";
option optimize_for = LITE_RUNTIME;
